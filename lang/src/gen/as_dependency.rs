// Copyright 2018-2019 Parity Technologies (UK) Ltd.
// This file is part of ink!.
//
// ink! is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// ink! is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ink!.  If not, see <http://www.gnu.org/licenses/>.

//! Code generation for smart contracts when they are compiled as a dependency of another smart contract
//! using the generally available `ink-as-dependency` crate feature.
//!
//! The code generated by this generally conflicts with other generated code since an ink! contract
//! that is compiled as dependency no longer requires any infrastructure to dispatch calls or instantiations.
//! However, it requires special treatment for all public messages since their bodies are completely
//! replaced by direct forwards to the remote call infrastructure going through SRML contracts.

use crate::{
    ast,
    hir,
};
use proc_macro2::{
    Ident,
    Span,
    TokenStream as TokenStream2,
};
use quote::{
    quote,
    ToTokens,
};
use std::iter;
use syn::{
    punctuated::Punctuated,
    Token,
};

pub fn generate_code(tokens: &mut TokenStream2, contract: &hir::Contract) {
    let messages = generate_messages_as_dependency(contract);
    let ext_call_messages = generate_ext_call_as_dependency(contract);
    let state = generate_state_as_dependency(contract);
    let contract_ident = &contract.name;

    tokens.extend(quote! {
        #[cfg(feature = "ink-as-dependency")]
        mod as_dependency {
            use super::*;

            #state

            const _: () = {
                impl<E> #contract_ident<E>
                where
                    E: ink_core::env::Env,
                    E::Balance: Default,
                    E::AccountId: Clone,
                {
                    #(#messages)*
                }

                impl<'a, E> ExtCallWrapper<'a, E>
                where
                    E: ink_core::env::Env,
                    E::Balance: Default,
                    E::AccountId: Clone,
                {
                    #(#ext_call_messages)*
                }
            };
        }
    });
}

fn generate_state_as_dependency(contract: &hir::Contract) -> TokenStream2 {
    let name = &contract.name;
    let attrs = &contract.state.attrs;
    quote! {
        #( #attrs )*
        pub struct #name<E: ink_core::env::Env> {
            account_id: E::AccountId,
        }

        #( #attrs )*
        pub struct ExtCallWrapper<'a, E: ink_core::env::Env> {
            contract: &'a #name,
        }

        impl<E> #name<E>
        where
            E: ink_core::env::Env,
        {
            pub fn from_address(account_id: E::AccountId) -> Self {
                Self { account_id }
            }

            pub fn ext(&self) -> ExtCallWrapper {
                ExtCallWrapper { contract: self }
            }
        }
    }
}

fn generate_messages_as_dependency<'a>(
    contract: &'a hir::Contract,
) -> impl Iterator<Item = TokenStream2> + 'a {
    contract.messages
        .iter()
        .map(|message| {
            let ident = &message.sig.ident;
            let attrs = &message.attrs;
            let args = message.sig.decl.inputs.iter();
            let inputs = message.sig.decl.inputs
                .iter()
                .filter_map(ast::FnArg::ident)
                .map(|ident| quote! { #ident });
            let output = &message.sig.decl.output;
            let (impl_generics, type_generics, where_clause) = message.sig.decl.generics.split_for_impl();
            let selector = message.selector();
            match output {
                syn::ReturnType::Default => quote! {
                    #(#attrs)*
                    pub fn #ident #type_generics ( #(#args ,)* ) #where_clause {
                        ink_core::env::CallBuilder::<E>::invoke(self.account_id.clone(), #selector)
                            #(
                                .push_arg(#inputs)
                            )*
                            .fire()
                            .expect("invocation of remote smart contract was invalid")
                    }
                },
                syn::ReturnType::Type(_, ty) => quote! {
                    #(#attrs)*
                    pub fn #ident #type_generics ( #(#args ,)* ) -> #ty #where_clause {
                        ink_core::env::CallBuilder::<E, _>::eval(self.account_id.clone(), #selector)
                            #(
                                .push_arg(&#inputs)
                            )*
                            .fire()
                            .expect("evaluation of remote smart contract was invalid")
                    }
                }
            }
        })
}

fn generate_ext_call_as_dependency<'a>(
    contract: &'a hir::Contract,
) -> impl Iterator<Item = TokenStream2> + 'a {
    contract.messages
        .iter()
        .map(|message| {
            let ident = &message.sig.ident;
            let attrs = &message.attrs;
            let args = message.sig.decl.inputs.iter();
            let inputs = message.sig.decl.inputs
                .iter()
                .filter_map(ast::FnArg::ident)
                .map(|ident| quote! { #ident });
            let output = &message.sig.decl.output;
            let (impl_generics, type_generics, where_clause) = message.sig.decl.generics.split_for_impl();
            let selector = message.selector();
            match output {
                syn::ReturnType::Default => quote! {
                    #(#attrs)*
                    pub fn #ident #type_generics ( #(#args ,)* ) -> ink_core::env::CallBuilder #where_clause {
                        ink_core::env::CallBuilder::<E>::invoke(self.account_id.clone(), #selector)
                            #(
                                .push_arg(#inputs)
                            )*
                    }
                },
                syn::ReturnType::Type(_, ty) => quote! {
                    #(#attrs)*
                    pub fn #ident #type_generics ( #(#args ,)* ) -> ink_core::env::CallBuilder #where_clause {
                        ink_core::env::CallBuilder::<E, ink_core::env::ReturnType<#ty>>::eval(self.account_id.clone(), #selector)
                            #(
                                .push_arg(&#inputs)
                            )*
                    }
                }
            }
        })
}
